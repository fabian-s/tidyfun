% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/convert.R, R/tfd-class.R
\name{as.tfd}
\alias{as.tfd}
\alias{as.tfd_irreg}
\alias{as.data.frame.tfd}
\alias{as.matrix.tfd}
\alias{tfd}
\alias{tfd.matrix}
\alias{tfd.numeric}
\alias{tfd.data.frame}
\alias{tfd.list}
\alias{tfd.tf}
\alias{tfd.default}
\title{Constructors & converters for "raw" functional data}
\usage{
as.tfd(data, ...)

as.tfd_irreg(data, ...)

\method{as.data.frame}{tfd}(
  x,
  row.names = NULL,
  optional = FALSE,
  arg = NULL,
  interpolate = FALSE,
  ...
)

\method{as.matrix}{tfd}(x, arg = NULL, interpolate = FALSE, ...)

tfd(data, ...)

\method{tfd}{matrix}(
  data,
  arg = NULL,
  domain = NULL,
  evaluator = tf_approx_linear,
  resolution = NULL,
  ...
)

\method{tfd}{numeric}(
  data,
  arg = NULL,
  domain = NULL,
  evaluator = tf_approx_linear,
  resolution = NULL,
  ...
)

\method{tfd}{data.frame}(
  data,
  id = 1,
  arg = 2,
  value = 3,
  domain = NULL,
  evaluator = tf_approx_linear,
  resolution = NULL,
  ...
)

\method{tfd}{list}(
  data,
  arg = NULL,
  domain = NULL,
  evaluator = tf_approx_linear,
  resolution = NULL,
  ...
)

\method{tfd}{tf}(data, arg = NULL, domain = NULL, evaluator = NULL, resolution = NULL, ...)

\method{tfd}{default}(
  data,
  arg = NULL,
  domain = NULL,
  evaluator = tf_approx_linear,
  resolution = NULL,
  ...
)
}
\arguments{
\item{data}{a \code{matrix}, \code{data.frame} or \code{list} of suitable shape, or another \code{tf}-object. when
this argument is \code{NULL} (i.e. when calling \code{tfd()}) this returns a prototype of class \code{tfd}}

\item{...}{not used in \code{tfd}, except for \code{tfd.tf} -- specify \code{arg} and \code{ìnterpolate = TRUE} to
turn an irregular \code{tfd} into a regular one, see examples.}

\item{x}{an \code{tfd} object}

\item{row.names}{not used}

\item{optional}{not used}

\item{arg}{\code{numeric}, or list of \code{numeric}s. The evaluation grid. See Details.
For the \code{data.frame}-method: the name/number of the column defining the evaluation grid.}

\item{interpolate}{should functions be evaluated (i.e., inter-/extrapolated)
for values in \code{arg} for which no original data is available? Only relevant for
\code{tfd}, defaults to \code{TRUE}.}

\item{domain}{range of the \code{arg}.}

\item{evaluator}{a function accepting arguments \verb{x, arg, evaluations}. See details for \code{\link[=tfd]{tfd()}}.}

\item{resolution}{resolution of the evaluation grid. See details for \code{\link[=tfd]{tfd()}}.}

\item{id}{The name/number of the column defining which data belong to which function.}

\item{value}{The name/number of the column containing the function evaluations.}
}
\value{
an \code{tfd}-object (or a \code{data.frame}/\code{matrix} for the conversion functions, obviously.)
}
\description{
Various constructor and conversion methods.

\code{tfd.data.frame} uses the first 3 columns of \code{data} for function information by default:
(\code{ìd}, \code{arg}, \code{value})

\code{tfd.list} accepts a list of vectors of identical lengths
containing evaluations or a list of 2-column matrices/data.frames with
\code{arg} in the first and evaluations in the second column

return class prototype when argument to tfd() is NULL or not a recongised class
}
\details{
\strong{\code{evaluator}}: must be the (quoted or bare) name of a
\verb{function(x, arg, evaluations)} that returns
the functions' (tf_approximated/interpolated) values at locations \code{x} based on
the \code{evaluations} available at locations \code{arg}.\cr
Available \code{evaluator}-functions:
\itemize{
\item \code{tf_approx_linear} for linear interpolation without extrapolation (i.e.,
\code{\link[zoo:na.approx]{zoo::na.approx()}} with \code{na.rm = FALSE})  -- this is the default,
\item \code{tf_approx_spline} for cubic spline interpolation, (i.e., \code{\link[zoo:na.approx]{zoo::na.spline()}}
with \code{na.rm = FALSE}),
\item \code{tf_approx_fill_extend} for linear interpolation and constant extrapolation
(i.e., \code{\link[zoo:na.fill]{zoo::na.fill()}} with \code{fill = "extend"})
\item \code{tf_approx_locf} for "last observation carried forward"  (i.e.,
\code{\link[zoo:na.locf]{zoo::na.locf()}} with \code{na.rm = FALSE} and
\item \code{tf_approx_nocb} for "next observation carried backward" (i.e.,
\code{\link[zoo:na.locf]{zoo::na.locf()}} with \verb{na.rm = FALSE, fromLast = TRUE}).
See \code{tidyfun:::zoo_wrapper} and \code{tidyfun:::tf_approx_linear}, which is simply
\code{zoo_wrapper(zoo::na.tf_approx, na.rm = FALSE)}, for examples of implementations of
this.
}

\strong{\code{resolution}}: \code{arg}-values that are equivalent up to this difference are
treated as identical. E.g., if an evaluation of $f(t)$ is available at $t=1$
and a function value is requested at $t = 1.01$, $f(1)$ will be returned if
\code{resolution} < .01. By default, resolution will be set to an integer-valued power
of 10 one smaller than smallest difference between adjacent
arg-values rounded down to an integer-valued power
of 10: e.g., if the smallest difference between consecutive
arg-values is between $0.1 and 0.9999$, the resolution will be $0.01$, etc.
In code: \verb{10^(floor(log10(min(diff(<arg>))) - 1)}
}
\examples{
#turn irregular to regular tfd
#TODO: add extra function/verb for this

(f <- c(tf_rgp(1, arg = seq(0,1,l=11)), tf_rgp(1, arg = seq(0,1,l=21))))
tfd(f, interpolate = TRUE, arg = seq(0,1,l=21))

(f <- c(dti_df$cca[1], dti_df$rcst[2]))
tfd(f, interpolate = TRUE, arg = seq(0,1,l=21))

}
